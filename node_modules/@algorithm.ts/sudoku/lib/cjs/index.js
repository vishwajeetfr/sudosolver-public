'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var knuthShuffle = require('@algorithm.ts/knuth-shuffle');
var dlx = require('@algorithm.ts/dlx');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var knuthShuffle__default = /*#__PURE__*/_interopDefaultLegacy(knuthShuffle);

function createSudokuBoard(SUDOKU_SIZE) {
    const board = new Array(SUDOKU_SIZE);
    for (let r = 0; r < SUDOKU_SIZE; ++r) {
        board[r] = new Array(SUDOKU_SIZE);
    }
    return board;
}
function fillSudokuBoard(board, v, SUDOKU_SIZE = board.length) {
    for (let r = 0; r < SUDOKU_SIZE; ++r) {
        for (let c = 0; c < SUDOKU_SIZE; ++c) {
            board[r][c] = v;
        }
    }
}
function copySudokuBoard(src, dst, SUDOKU_SIZE = src.length) {
    for (let r = 0; r < SUDOKU_SIZE; ++r) {
        for (let c = 0; c < SUDOKU_SIZE; ++c) {
            dst[r][c] = src[r][c];
        }
    }
}
function checkSudokuSolution(solution, SUDOKU_SIZE_SQRT) {
    const SUDOKU_SIZE = SUDOKU_SIZE_SQRT * SUDOKU_SIZE_SQRT;
    const nums = new Array(SUDOKU_SIZE);
    let target = 0;
    for (let r = 0; r < SUDOKU_SIZE; ++r, ++target) {
        for (let c = 0; c < SUDOKU_SIZE; ++c) {
            const w = solution[r][c];
            if (w === -1 || nums[w] === target)
                return false;
            nums[w] = target;
        }
    }
    for (let c = 0; c < SUDOKU_SIZE; ++c, ++target) {
        for (let r = 0; r < SUDOKU_SIZE; ++r) {
            const w = solution[r][c];
            if (w === -1 || nums[w] === target)
                return false;
            nums[w] = target;
        }
    }
    for (let x = 0; x < SUDOKU_SIZE_SQRT; ++x) {
        for (let y = 0; y < SUDOKU_SIZE_SQRT; ++y, ++target) {
            for (let a = 0; a < SUDOKU_SIZE_SQRT; ++a) {
                const r = x * SUDOKU_SIZE_SQRT + a;
                for (let b = 0; b < SUDOKU_SIZE_SQRT; ++b) {
                    const c = y * SUDOKU_SIZE_SQRT + b;
                    const w = solution[r][c];
                    if (w === -1 || nums[w] === target)
                        return false;
                    nums[w] = target;
                }
            }
        }
    }
    return true;
}
function createSegmentCodeMap(SUDOKU_SIZE_SQRT) {
    const SUDOKU_SIZE = SUDOKU_SIZE_SQRT * SUDOKU_SIZE_SQRT;
    const segmentCodeMap = new Array(SUDOKU_SIZE);
    for (let i = 0, s = 0, j; i < SUDOKU_SIZE; i = j, ++s) {
        j = i + SUDOKU_SIZE_SQRT;
        segmentCodeMap.fill(s, i, j);
    }
    return segmentCodeMap;
}

exports.SudokuConstraint = void 0;
(function (SudokuConstraint) {
    SudokuConstraint[SudokuConstraint["SLOT"] = 0] = "SLOT";
    SudokuConstraint[SudokuConstraint["ROW"] = 1] = "ROW";
    SudokuConstraint[SudokuConstraint["COL"] = 2] = "COL";
    SudokuConstraint[SudokuConstraint["SUB"] = 3] = "SUB";
})(exports.SudokuConstraint || (exports.SudokuConstraint = {}));
class SudokuSolver {
    SUDOKU_SIZE_SQRT;
    SUDOKU_SIZE;
    SUDOKU_SIZE_SQUARE;
    DL_TOTAL_COLUMNS;
    constraints = new Array(4);
    segmentCodeMap;
    dlx;
    constructor(options) {
        const { childMatrixSize } = options;
        const SUDOKU_SIZE_SQRT = childMatrixSize;
        const SUDOKU_SIZE = SUDOKU_SIZE_SQRT * SUDOKU_SIZE_SQRT;
        const SUDOKU_SIZE_SQUARE = SUDOKU_SIZE * SUDOKU_SIZE;
        const DL_TOTAL_COLUMNS = SUDOKU_SIZE * SUDOKU_SIZE * 4;
        const DL_MAX_ROWS = SUDOKU_SIZE * SUDOKU_SIZE * SUDOKU_SIZE;
        const DL_MAX_NODES = DL_TOTAL_COLUMNS * DL_MAX_ROWS + SUDOKU_SIZE + 1;
        const dlx$1 = dlx.createDLX(DL_MAX_NODES);
        this.dlx = dlx$1;
        this.SUDOKU_SIZE_SQRT = SUDOKU_SIZE_SQRT;
        this.SUDOKU_SIZE = SUDOKU_SIZE;
        this.SUDOKU_SIZE_SQUARE = SUDOKU_SIZE_SQUARE;
        this.DL_TOTAL_COLUMNS = DL_TOTAL_COLUMNS;
        this.segmentCodeMap = createSegmentCodeMap(SUDOKU_SIZE_SQRT);
    }
    solve(puzzle, solution) {
        const { SUDOKU_SIZE_SQRT, SUDOKU_SIZE, SUDOKU_SIZE_SQUARE, DL_TOTAL_COLUMNS: SUDOKU_NODES, constraints, segmentCodeMap, dlx, } = this;
        const encode = (a, b, c) => a * SUDOKU_SIZE_SQUARE + b * SUDOKU_SIZE + c + 1;
        dlx.init(SUDOKU_NODES);
        for (let r = 0; r < SUDOKU_SIZE; ++r) {
            for (let c = 0; c < SUDOKU_SIZE; ++c) {
                const s = segmentCodeMap[r] * SUDOKU_SIZE_SQRT + segmentCodeMap[c];
                const w = puzzle[r][c];
                for (let v = 0; v < SUDOKU_SIZE; ++v) {
                    if (w === -1 || w === v) {
                        constraints[0] = encode(exports.SudokuConstraint.SLOT, r, c);
                        constraints[1] = encode(exports.SudokuConstraint.ROW, r, v);
                        constraints[2] = encode(exports.SudokuConstraint.COL, c, v);
                        constraints[3] = encode(exports.SudokuConstraint.SUB, s, v);
                        dlx.addRow(encode(r, c, v), constraints);
                    }
                }
            }
        }
        const answer = dlx.solve();
        if (answer === null)
            return false;
        if (solution !== null) {
            for (const _code of answer) {
                let code = _code - 1;
                const c = code % SUDOKU_SIZE;
                code = (code / SUDOKU_SIZE) >> 0;
                const b = code % SUDOKU_SIZE;
                code = (code / SUDOKU_SIZE) >> 0;
                const a = code;
                solution[a][b] = c;
            }
        }
        return true;
    }
}

class SudokuCreator {
    SUDOKU_SIZE_SQRT;
    SUDOKU_SIZE;
    SUDOKU_SIZE_SQUARE;
    solver;
    segmentCodeMap;
    gridCodes;
    candidates;
    visitedNums;
    tmpBoard;
    difficulty;
    constructor(options) {
        const { childMatrixSize, difficulty = 0.2 } = options;
        const SUDOKU_SIZE_SQRT = childMatrixSize;
        const SUDOKU_SIZE = SUDOKU_SIZE_SQRT * SUDOKU_SIZE_SQRT;
        const SUDOKU_SIZE_SQUARE = SUDOKU_SIZE * SUDOKU_SIZE;
        const solver = new SudokuSolver({ childMatrixSize: SUDOKU_SIZE_SQRT });
        this.solver = solver;
        this.SUDOKU_SIZE_SQRT = SUDOKU_SIZE_SQRT;
        this.SUDOKU_SIZE = SUDOKU_SIZE;
        this.SUDOKU_SIZE_SQUARE = SUDOKU_SIZE_SQUARE;
        this.difficulty = this.resolveDifficulty(difficulty);
        this.segmentCodeMap = createSegmentCodeMap(SUDOKU_SIZE_SQRT);
        const gridCodes = new Array(SUDOKU_SIZE_SQUARE);
        this.gridCodes = gridCodes;
        for (let r = 0, i = 0; r < SUDOKU_SIZE; ++r) {
            const u = r << 16;
            for (let c = 0; c < SUDOKU_SIZE; ++c, ++i) {
                gridCodes[i] = u | c;
            }
        }
        this.candidates = new Array(SUDOKU_SIZE);
        this.visitedNums = new Array(SUDOKU_SIZE);
        this.tmpBoard = createSudokuBoard(SUDOKU_SIZE);
    }
    createSudoku(_difficulty) {
        if (_difficulty != null) {
            this.difficulty = this.resolveDifficulty(_difficulty);
        }
        const solution = this.createSolution();
        const puzzle = this.createPuzzle(solution);
        return { puzzle, solution: solution };
    }
    createSolution() {
        const { SUDOKU_SIZE, SUDOKU_SIZE_SQUARE } = this;
        const { candidates, gridCodes, solver, tmpBoard: radicalPuzzle } = this;
        fillSudokuBoard(radicalPuzzle, -1);
        knuthShuffle__default["default"](gridCodes);
        const _end = Math.floor((Math.random() * 0.3 + 0.2) * SUDOKU_SIZE_SQUARE);
        for (let i = 0; i < _end; ++i) {
            const p = gridCodes[i];
            const r = p >> 16;
            const c = p & 0xffff;
            const candidatesSize = this.calcCandidates(radicalPuzzle, r, c);
            if (candidatesSize < 1)
                continue;
            const x = knuthShuffle.randomInt(candidatesSize);
            const v = candidates[x];
            radicalPuzzle[r][c] = v;
        }
        const solution = createSudokuBoard(SUDOKU_SIZE);
        for (let i = 0; i < _end; ++i) {
            if (solver.solve(radicalPuzzle, solution))
                return solution;
            const p = gridCodes[i];
            const r = p >> 16;
            const c = p & 0xffff;
            radicalPuzzle[r][c] = -1;
        }
        throw new Error('[createSolution] This is impossible!');
    }
    createPuzzle(solution) {
        const { SUDOKU_SIZE, SUDOKU_SIZE_SQUARE } = this;
        const { candidates, gridCodes, solver, difficulty } = this;
        const puzzle = createSudokuBoard(SUDOKU_SIZE);
        copySudokuBoard(solution, puzzle);
        knuthShuffle__default["default"](gridCodes);
        const _end = Math.floor(SUDOKU_SIZE_SQUARE * difficulty);
        for (let i = 0; i < _end; ++i) {
            const p = gridCodes[i];
            const r = p >> 16;
            const c = p & 0xffff;
            const candidatesSize = this.calcCandidates(puzzle, r, c);
            let j = 0;
            if (candidatesSize > 0) {
                for (; j < candidatesSize; ++j) {
                    puzzle[r][c] = candidates[j];
                    if (solver.solve(puzzle, null))
                        break;
                }
            }
            puzzle[r][c] = j < candidatesSize ? solution[r][c] : -1;
        }
        return puzzle;
    }
    calcCandidates(board, r, c) {
        const { SUDOKU_SIZE_SQRT, SUDOKU_SIZE } = this;
        const { segmentCodeMap, candidates, visitedNums } = this;
        visitedNums.fill(false);
        for (let i = 0; i < SUDOKU_SIZE; ++i) {
            const v = board[r][i];
            if (v === -1)
                continue;
            visitedNums[v] = true;
        }
        for (let i = 0; i < SUDOKU_SIZE; ++i) {
            const v = board[i][c];
            if (v === -1)
                continue;
            visitedNums[v] = true;
        }
        const sr = segmentCodeMap[r] * SUDOKU_SIZE_SQRT;
        const sc = segmentCodeMap[c] * SUDOKU_SIZE_SQRT;
        for (let i = 0; i < SUDOKU_SIZE_SQRT; ++i) {
            const _r = sr + i;
            for (let j = 0; j < SUDOKU_SIZE_SQRT; ++j) {
                const _c = sc + j;
                const v = board[_r][_c];
                if (v === -1)
                    continue;
                visitedNums[v] = true;
            }
        }
        let tot = 0;
        for (let v = 0; v < SUDOKU_SIZE; ++v) {
            if (visitedNums[v])
                continue;
            candidates[tot++] = v;
        }
        return tot;
    }
    resolveDifficulty(_difficulty) {
        const difficulty = Math.max(0, Math.min(1, _difficulty)) * 0.8 + 0.2;
        return difficulty;
    }
}

exports.SudokuCreator = SudokuCreator;
exports.SudokuSolver = SudokuSolver;
exports.checkSudokuSolution = checkSudokuSolution;
exports.copySudokuBoard = copySudokuBoard;
exports.createSegmentCodeMap = createSegmentCodeMap;
exports.createSudokuBoard = createSudokuBoard;
exports.fillSudokuBoard = fillSudokuBoard;
