'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function createDLX(MAX_N) {
    let sz;
    const selectedRowNos = new Array(MAX_N);
    let countOfSelectedRows;
    const count = new Array(MAX_N);
    const row = new Array(MAX_N);
    const col = new Array(MAX_N);
    const L = new Array(MAX_N);
    const R = new Array(MAX_N);
    const U = new Array(MAX_N);
    const D = new Array(MAX_N);
    return { init, destroy, addRow, solve };
    function init(_totalColumns) {
        sz = _totalColumns + 1;
        for (let i = 0; i < sz; ++i) {
            L[i] = i - 1;
            R[i] = i + 1;
            U[i] = i;
            D[i] = i;
        }
        R[_totalColumns] = 0;
        L[0] = _totalColumns;
        count.fill(0, 0, sz);
    }
    function destroy() {
        selectedRowNos.length = 0;
        count.length = 0;
        row.length = 0;
        col.length = 0;
        L.length = 0;
        R.length = 0;
        U.length = 0;
        D.length = 0;
    }
    function addRow(r, columns) {
        const first = sz;
        for (let i = 0; i < columns.length; ++i, ++sz) {
            const c = columns[i];
            row[sz] = r;
            col[sz] = c;
            count[c] += 1;
            L[sz] = sz - 1;
            R[sz] = sz + 1;
            D[sz] = c;
            D[U[c]] = sz;
            U[sz] = U[c];
            U[c] = sz;
        }
        R[sz - 1] = first;
        L[first] = sz - 1;
    }
    function solve() {
        if (!algorithmX(0))
            return null;
        return selectedRowNos.slice(0, countOfSelectedRows);
    }
    function removeColumn(c) {
        L[R[c]] = L[c];
        R[L[c]] = R[c];
        for (let i = D[c]; i !== c; i = D[i]) {
            for (let j = R[i]; j !== i; j = R[j]) {
                U[D[j]] = U[j];
                D[U[j]] = D[j];
                count[col[j]] -= 1;
            }
        }
    }
    function restoreColumn(c) {
        for (let i = U[c]; i !== c; i = U[i]) {
            for (let j = L[i]; j !== i; j = L[j]) {
                count[col[j]] += 1;
                U[D[j]] = j;
                D[U[j]] = j;
            }
        }
        L[R[c]] = c;
        R[L[c]] = c;
    }
    function algorithmX(dep) {
        if (R[0] === 0) {
            countOfSelectedRows = dep;
            return true;
        }
        let c = R[0];
        for (let i = R[0]; i !== 0; i = R[i]) {
            if (count[i] < count[c])
                c = i;
        }
        removeColumn(c);
        for (let i = D[c]; i !== c; i = D[i]) {
            selectedRowNos[dep] = row[i];
            for (let j = R[i]; j !== i; j = R[j])
                removeColumn(col[j]);
            if (algorithmX(dep + 1))
                return true;
            for (let j = L[i]; j !== i; j = L[j])
                restoreColumn(col[j]);
        }
        restoreColumn(c);
        return false;
    }
}

exports.createDLX = createDLX;
